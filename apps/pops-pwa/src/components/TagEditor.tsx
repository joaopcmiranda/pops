/**
 * TagEditor ‚Äî inline popover for editing transaction tags.
 * Shows current tags as removable chips, with autocomplete from known tags
 * and a "Suggest" button backed by an async callback.
 *
 * This component is tRPC-agnostic ‚Äî callers wire up the API.
 */
import { useState, useRef, useEffect } from "react";
import { Chip } from "./Chip";
import { Popover, PopoverContent, PopoverTrigger } from "./ui/popover";
import { Badge } from "./ui/badge";
import { cn } from "@/lib/utils";

/** Source attribution for a tag ‚Äî from AI, correction rule, or entity defaults. */
export type TagSource = "ai" | "rule" | "entity";

export interface TagMetaEntry {
  source: TagSource;
  /** For rule-sourced tags: the description_pattern from the matched correction. */
  pattern?: string;
}

export interface TagEditorProps {
  /** Current tags on the transaction. */
  currentTags: string[];
  /** Called with the final tag list when the user saves. May be async. */
  onSave: (tags: string[]) => void | Promise<void>;
  /** Optional async callback for AI-powered tag suggestions. */
  onSuggest?: () => Promise<string[]>;
  /**
   * Available tags for autocomplete ‚Äî sourced dynamically from the
   * transactions.availableTags endpoint (Notion Tags multi_select options).
   * Users may still type any free-form string not in this list.
   */
  availableTags?: string[];
  /** Whether to disable editing (shows tags read-only). */
  disabled?: boolean;
  /**
   * Optional source attribution metadata keyed by tag name.
   * When provided, source icons and pattern tooltips are shown in the trigger button.
   */
  tagMeta?: Map<string, TagMetaEntry>;
}

/**
 * Inline tag editor that opens as a popover.
 *
 * @example
 * ```tsx
 * <TagEditor
 *   currentTags={["Groceries"]}
 *   onSave={async (tags) => { await updateTransaction({ tags }) }}
 *   onSuggest={async () => suggestTags(description, entityId)}
 * />
 * ```
 */
const SOURCE_ICONS: Record<TagSource, string> = {
  ai: "ü§ñ",
  rule: "üìã",
  entity: "üè™",
};

export function TagEditor({
  currentTags,
  onSave,
  onSuggest,
  availableTags = [],
  disabled = false,
  tagMeta,
}: TagEditorProps) {
  const [open, setOpen] = useState(false);
  const [tags, setTags] = useState<string[]>(currentTags);
  const [inputValue, setInputValue] = useState("");
  const [isSaving, setIsSaving] = useState(false);
  const [isSuggesting, setIsSuggesting] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  const allKnownTags = availableTags;

  // Reset local tags when prop changes (e.g. after successful external update)
  useEffect(() => {
    setTags(currentTags);
  }, [currentTags]);

  const filteredSuggestions = (() => {
    if (inputValue === "") {
      return allKnownTags.filter((tag) => !tags.includes(tag));
    }
    const lower = inputValue.toLowerCase();
    const startsWith: string[] = [];
    const contains: string[] = [];
    for (const tag of allKnownTags) {
      if (tags.includes(tag)) continue;
      const tagLower = tag.toLowerCase();
      if (tagLower.startsWith(lower)) startsWith.push(tag);
      else if (tagLower.includes(lower)) contains.push(tag);
    }
    return [...startsWith, ...contains];
  })();

  function addTag(tag: string) {
    const trimmed = tag.trim();
    if (trimmed && !tags.includes(trimmed)) {
      setTags((prev) => [...prev, trimmed]);
    }
    setInputValue("");
    inputRef.current?.focus();
  }

  function removeTag(tag: string) {
    setTags((prev) => prev.filter((t) => t !== tag));
  }

  function handleKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === "Tab" && filteredSuggestions.length > 0) {
      e.preventDefault();
      addTag(filteredSuggestions[0]);
      return;
    }
    if ((e.key === "Enter" || e.key === ",") && inputValue.trim()) {
      e.preventDefault();
      addTag(inputValue);
      return;
    }
    if (e.key === "Backspace" && !inputValue && tags.length > 0) {
      removeTag(tags[tags.length - 1]);
      return;
    }
    if (e.key === "Escape") {
      handleCancel();
    }
  }

  async function handleSave() {
    setIsSaving(true);
    try {
      await onSave(tags);
      setOpen(false);
    } finally {
      setIsSaving(false);
    }
  }

  async function handleSuggest() {
    if (!onSuggest) return;
    setIsSuggesting(true);
    try {
      const suggested = await onSuggest();
      const newTags = suggested.filter((t) => !tags.includes(t));
      setTags((prev) => [...prev, ...newTags]);
    } finally {
      setIsSuggesting(false);
    }
  }

  function handleCancel() {
    setTags(currentTags);
    setInputValue("");
    setOpen(false);
  }

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <button
          className={cn(
            "flex flex-wrap gap-1 min-h-6 text-left w-full rounded px-1 py-0.5 transition-colors",
            disabled
              ? "cursor-default"
              : "hover:bg-accent/50 cursor-pointer"
          )}
          aria-label="Edit tags"
          disabled={disabled}
        >
          {tags.length === 0 ? (
            <span className="text-muted-foreground text-xs">‚Äî</span>
          ) : (
            tags.slice(0, 3).map((tag) => {
              const meta = tagMeta?.get(tag);
              const tooltipText = meta?.source === "rule" && meta?.pattern
                ? `Rule: "${meta.pattern}"`
                : meta?.source
                ? `${meta.source} suggestion`
                : undefined;
              return (
                <Badge
                  key={tag}
                  variant="secondary"
                  className="text-xs"
                  title={tooltipText}
                >
                  {meta ? `${SOURCE_ICONS[meta.source]} ` : ""}
                  {tag}
                </Badge>
              );
            })
          )}
          {tags.length > 3 && (
            <Badge variant="secondary" className="text-xs">
              +{tags.length - 3}
            </Badge>
          )}
        </button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-3" align="start">
        <div className="space-y-3">
          <p className="text-sm font-medium">Edit tags</p>

          {/* Current tags as removable chips */}
          {tags.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {tags.map((tag) => (
                <Chip key={tag} size="sm" removable onRemove={() => removeTag(tag)}>
                  {tag}
                </Chip>
              ))}
            </div>
          )}

          {/* Text input */}
          <input
            ref={inputRef}
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Type to add a tag‚Ä¶"
            className="w-full text-sm border border-border rounded px-2 py-1.5 bg-background focus:outline-none focus:ring-1 focus:ring-ring"
            autoFocus
          />

          {/* Autocomplete suggestions */}
          {filteredSuggestions.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {filteredSuggestions.slice(0, 8).map((tag) => (
                <button
                  key={tag}
                  onClick={() => addTag(tag)}
                  className={cn(
                    "text-xs px-2 py-0.5 border border-border rounded-full",
                    "hover:bg-accent hover:border-accent-foreground/20 transition-colors"
                  )}
                >
                  + {tag}
                </button>
              ))}
            </div>
          )}

          {/* Actions */}
          <div className="flex items-center justify-between pt-1">
            {onSuggest ? (
              <button
                onClick={handleSuggest}
                disabled={isSuggesting}
                className="text-xs text-muted-foreground hover:text-foreground underline disabled:opacity-50"
              >
                {isSuggesting ? "Suggesting‚Ä¶" : "Suggest"}
              </button>
            ) : (
              <span />
            )}
            <div className="flex gap-2">
              <button
                onClick={handleCancel}
                className="text-xs px-2 py-1 border border-border rounded hover:bg-accent transition-colors"
              >
                Cancel
              </button>
              <button
                onClick={handleSave}
                disabled={isSaving}
                className="text-xs px-2 py-1 bg-primary text-primary-foreground rounded hover:bg-primary/90 disabled:opacity-50 transition-colors"
              >
                {isSaving ? "Saving‚Ä¶" : "Save"}
              </button>
            </div>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  );
}
